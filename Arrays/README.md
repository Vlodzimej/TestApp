# Динамические массивы, неполный массив, очередь с приоритетом.

## Динамические массивы (100000 операций), мс

| Тип массива  | Вставка в конец | Вставка в начало | Вставка случайная | Чтение с конца | Чтение с начала | Чтение случайное | Удаление с конца | Удаление с начала | Удаление случайное |
| ------------ | :-------------: | :--------------: | :---------------: | :------------: | :-------------: | :--------------: | :--------------: | :---------------: | :----------------: |
| Single Array |      2049       |      14543       |       10446       |       0        |        0        |        2         |      10560       |       2389        |       10056        |
| Vector Array |       23        |       2338       |       2804        |       1        |        1        |        3         |        2         |       3751        |        4418        |
| Factor Array |       26        |       1958       |       2853        |       3        |        2        |        6         |        1         |       5997        |        4128        |
| Matrix Array |        5        |       9008       |       8997        |       4        |        4        |        6         |        8         |       7303        |        7053        |
| Matrix List  |        4        |       2469       |       1168        |       1        |        1        |        3         |        4         |       2063        |        1007        |

Статистика тестирования различных реализаций массива показывает, что улучшения алгоритмов позволяют добиться увеличения производительности при совершении операций предполагающих работу с крайними элементами массива.
Также заметно, что скорость операций в целом увеличивается при всех операциях вставки и некоторых операциях удаления элементов. Однако, в случае с Matrix Array, при совершении операций вставки и удаления производительность заметно ухудшается.
Достаточно большой перевес в сторону большей производительности показала реализациия Matrix Array на основе простого списка List (Matrix List) из чего можно сделать вывод, что нативная реализация списка достаточно хорошо оптимизирована.

_Время выполнения задания: 16 ч. 00 мин._

## Задание

Динамические массивы, неполный массив, очередь с приоритетом.
Цель: Создание разных алгоритмов для реализации Динамического массива и сравнение их производительности. Создание приоритетной очереди или неполного массива.

1 задание. Динамические массивы.
Написать метод добавления и удаления элементов:
void add(T item, int index);
T remove(int index); // возвращает удаляемый элемент
по индексу во все варианты динамических массивов:
SingleArray, VectorArray, FactorArray, MatrixArray \*.
+3 байта

2 задание. Таблица сравнения производительности.
Сравнить время выполнения разных операций
для разных массивов с разным порядком значений.

- сделать обёртку над ArrayList() и тоже сравнить.
  Составить таблицу и приложить её скриншот.
  Сделать выводы и сформулировать их в нескольких предложениях.
  +3 байта

3 задание. Приоритетная очередь (на выбор).
Написать реализацию PriorityQueue - очередь с приоритетом.
Варианты реализации - список списков, массив списков
Методы к реализации:
enqueue(int priority, T item) - поместить элемент в очередь
T dequeue() - выбрать элемент из очереди
+4 байта

4 задание. Неполный массив (на выбор).
Написать Реализацию класса SpaceArray массив массивов с неполным заполнением.
Делать на основе одного из уже созданных массивов и/или списков.
+4 байта дополнительно.

Напишите сколько времени ушло на домашнее задание.

Для реализации можно использовать только стандартные массивы [],
созданные классы массивов и/или списков. Стандартные коллекции не используем!

ВАЖНО! При размещении ответа укажите, на каком языке вы выполнили ДЗ. Это поможет нам ускорить его проверку.
Критерии оценки: 1 задание. Динамические массивы. +3 байта
2 задание. Таблица сравнение производительности. +3 байта
3 задание (на выбор). Приоритетная очередь. +4 байта
4 задание (на выбор). Класс SpaceArray +4 байта
